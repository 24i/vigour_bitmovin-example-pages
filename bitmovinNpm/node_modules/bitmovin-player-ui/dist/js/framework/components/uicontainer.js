"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var container_1 = require("./container");
var dom_1 = require("../dom");
var timeout_1 = require("../timeout");
var utils_1 = require("../utils");
/**
 * The base container that contains all of the UI. The UIContainer is passed to the {@link UIManager} to build and
 * setup the UI.
 */
var UIContainer = (function (_super) {
    __extends(UIContainer, _super);
    function UIContainer(config) {
        var _this = _super.call(this, config) || this;
        _this.config = _this.mergeConfig(config, {
            cssClass: 'ui-uicontainer',
            hideDelay: 5000,
        }, _this.config);
        return _this;
    }
    UIContainer.prototype.configure = function (player, uimanager) {
        _super.prototype.configure.call(this, player, uimanager);
        this.configureUIShowHide(player, uimanager);
        this.configurePlayerStates(player, uimanager);
    };
    UIContainer.prototype.configureUIShowHide = function (player, uimanager) {
        var self = this;
        var container = this.getDomElement();
        var config = this.getConfig();
        var isUiShown = false;
        var isSeeking = false;
        var showUi = function () {
            if (!isUiShown) {
                // Let subscribers know that they should reveal themselves
                uimanager.onControlsShow.dispatch(self);
                isUiShown = true;
            }
            // Don't trigger timeout while seeking, it will be triggered once the seek is finished
            if (!isSeeking) {
                uiHideTimeout.start();
            }
        };
        var hideUi = function () {
            if (isUiShown) {
                // Let subscribers know that they should now hide themselves
                uimanager.onControlsHide.dispatch(self);
                isUiShown = false;
            }
        };
        // Timeout to defer UI hiding by the configured delay time
        var uiHideTimeout = new timeout_1.Timeout(config.hideDelay, hideUi);
        // On touch displays, the first touch reveals the UI
        container.on('touchend', function (e) {
            if (!isUiShown) {
                // Only if the UI is hidden, we prevent other actions and reveal the UI instead
                e.preventDefault();
                showUi();
            }
        });
        // When the mouse enters, we show the UI
        container.on('mouseenter', function () {
            showUi();
        });
        // When the mouse moves within, we show the UI
        container.on('mousemove', function () {
            showUi();
        });
        // When the mouse leaves, we can prepare to hide the UI, except a seek is going on
        container.on('mouseleave', function () {
            // When a seek is going on, the seek scrub pointer may exit the UI area while still seeking, and we do not hide
            // the UI in such cases
            if (!isSeeking) {
                uiHideTimeout.start();
            }
        });
        uimanager.onSeek.subscribe(function () {
            uiHideTimeout.clear(); // Don't hide UI while a seek is in progress
            isSeeking = true;
        });
        uimanager.onSeeked.subscribe(function () {
            isSeeking = false;
            uiHideTimeout.start(); // Re-enable UI hide timeout after a seek
        });
    };
    UIContainer.prototype.configurePlayerStates = function (player, uimanager) {
        var self = this;
        var container = this.getDomElement();
        var removeStates = function () {
            container.removeClass(self.prefixCss(UIContainer.STATE_IDLE));
            container.removeClass(self.prefixCss(UIContainer.STATE_PREPARED));
            container.removeClass(self.prefixCss(UIContainer.STATE_PLAYING));
            container.removeClass(self.prefixCss(UIContainer.STATE_PAUSED));
            container.removeClass(self.prefixCss(UIContainer.STATE_FINISHED));
        };
        player.addEventHandler(bitmovin.player.EVENT.ON_READY, function () {
            removeStates();
            container.addClass(self.prefixCss(UIContainer.STATE_PREPARED));
        });
        player.addEventHandler(bitmovin.player.EVENT.ON_PLAY, function () {
            removeStates();
            container.addClass(self.prefixCss(UIContainer.STATE_PLAYING));
        });
        player.addEventHandler(bitmovin.player.EVENT.ON_PAUSED, function () {
            removeStates();
            container.addClass(self.prefixCss(UIContainer.STATE_PAUSED));
        });
        player.addEventHandler(bitmovin.player.EVENT.ON_PLAYBACK_FINISHED, function () {
            removeStates();
            container.addClass(self.prefixCss(UIContainer.STATE_FINISHED));
        });
        player.addEventHandler(bitmovin.player.EVENT.ON_SOURCE_UNLOADED, function () {
            removeStates();
            container.addClass(self.prefixCss(UIContainer.STATE_IDLE));
        });
        // Init in idle state without a source or prepared if a source is set
        container.addClass(self.prefixCss(utils_1.PlayerUtils.isSourceLoaded(player) ?
            UIContainer.STATE_PREPARED : UIContainer.STATE_IDLE));
        // Fullscreen marker class
        player.addEventHandler(bitmovin.player.EVENT.ON_FULLSCREEN_ENTER, function () {
            container.addClass(self.prefixCss(UIContainer.FULLSCREEN));
        });
        player.addEventHandler(bitmovin.player.EVENT.ON_FULLSCREEN_EXIT, function () {
            container.removeClass(self.prefixCss(UIContainer.FULLSCREEN));
        });
        // Init fullscreen state
        if (player.isFullscreen()) {
            container.addClass(self.prefixCss(UIContainer.FULLSCREEN));
        }
        // Buffering marker class
        player.addEventHandler(bitmovin.player.EVENT.ON_STALL_STARTED, function () {
            container.addClass(self.prefixCss(UIContainer.BUFFERING));
        });
        player.addEventHandler(bitmovin.player.EVENT.ON_STALL_ENDED, function () {
            container.removeClass(self.prefixCss(UIContainer.BUFFERING));
        });
        // Init buffering state
        if (player.isStalled()) {
            container.addClass(self.prefixCss(UIContainer.BUFFERING));
        }
        // Controls visibility marker class
        uimanager.onControlsShow.subscribe(function () {
            container.removeClass(self.prefixCss(UIContainer.CONTROLS_HIDDEN));
            container.addClass(self.prefixCss(UIContainer.CONTROLS_SHOWN));
        });
        uimanager.onControlsHide.subscribe(function () {
            container.removeClass(self.prefixCss(UIContainer.CONTROLS_SHOWN));
            container.addClass(self.prefixCss(UIContainer.CONTROLS_HIDDEN));
        });
        // Layout size classes
        var updateLayoutSizeClasses = function (width, height) {
            container.removeClass(self.prefixCss('layout-max-width-400'));
            container.removeClass(self.prefixCss('layout-max-width-600'));
            container.removeClass(self.prefixCss('layout-max-width-800'));
            container.removeClass(self.prefixCss('layout-max-width-1200'));
            if (width <= 400) {
                container.addClass(self.prefixCss('layout-max-width-400'));
            }
            else if (width <= 600) {
                container.addClass(self.prefixCss('layout-max-width-600'));
            }
            else if (width <= 800) {
                container.addClass(self.prefixCss('layout-max-width-800'));
            }
            else if (width <= 1200) {
                container.addClass(self.prefixCss('layout-max-width-1200'));
            }
        };
        player.addEventHandler(bitmovin.player.EVENT.ON_PLAYER_RESIZE, function (e) {
            // Convert strings (with "px" suffix) to ints
            var width = Math.round(Number(e.width.substring(0, e.width.length - 2)));
            var height = Math.round(Number(e.height.substring(0, e.height.length - 2)));
            updateLayoutSizeClasses(width, height);
        });
        // Init layout state
        updateLayoutSizeClasses(new dom_1.DOM(player.getFigure()).width(), new dom_1.DOM(player.getFigure()).height());
    };
    UIContainer.prototype.toDomElement = function () {
        var self = this;
        var container = _super.prototype.toDomElement.call(this);
        // Detect flexbox support (not supported in IE9)
        if (document && typeof document.createElement('p').style.flex !== 'undefined') {
            container.addClass(self.prefixCss('flexbox'));
        }
        else {
            container.addClass(self.prefixCss('no-flexbox'));
        }
        return container;
    };
    return UIContainer;
}(container_1.Container));
UIContainer.STATE_IDLE = 'player-state-idle';
UIContainer.STATE_PREPARED = 'player-state-prepared';
UIContainer.STATE_PLAYING = 'player-state-playing';
UIContainer.STATE_PAUSED = 'player-state-paused';
UIContainer.STATE_FINISHED = 'player-state-finished';
UIContainer.FULLSCREEN = 'fullscreen';
UIContainer.BUFFERING = 'buffering';
UIContainer.CONTROLS_SHOWN = 'controls-shown';
UIContainer.CONTROLS_HIDDEN = 'controls-hidden';
exports.UIContainer = UIContainer;
