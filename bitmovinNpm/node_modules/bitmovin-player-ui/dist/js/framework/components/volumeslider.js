"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var seekbar_1 = require("./seekbar");
var timeout_1 = require("../timeout");
/**
 * A simple volume slider component to adjust the player's volume setting.
 */
var VolumeSlider = (function (_super) {
    __extends(VolumeSlider, _super);
    function VolumeSlider(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, config) || this;
        _this.config = _this.mergeConfig(config, {
            cssClass: 'ui-volumeslider'
        }, _this.config);
        return _this;
    }
    VolumeSlider.prototype.configure = function (player, uimanager) {
        _super.prototype.configure.call(this, player, uimanager, false);
        var self = this;
        var volumeChangeHandler = function () {
            if (player.isMuted()) {
                self.setPlaybackPosition(0);
                self.setBufferPosition(0);
            }
            else {
                self.setPlaybackPosition(player.getVolume());
                self.setBufferPosition(player.getVolume());
            }
        };
        player.addEventHandler(bitmovin.player.EVENT.ON_VOLUME_CHANGED, volumeChangeHandler);
        player.addEventHandler(bitmovin.player.EVENT.ON_MUTED, volumeChangeHandler);
        player.addEventHandler(bitmovin.player.EVENT.ON_UNMUTED, volumeChangeHandler);
        this.onSeekPreview.subscribe(function (sender, args) {
            if (args.scrubbing) {
                player.setVolume(args.position);
            }
        });
        this.onSeeked.subscribe(function (sender, percentage) {
            player.setVolume(percentage);
        });
        player.addEventHandler(bitmovin.player.EVENT.ON_PLAYER_RESIZE, function () {
            self.refreshPlaybackPosition();
        });
        // Init volume bar
        volumeChangeHandler();
        // TODO find a better solution for this hack
        /* At the time where this is called, the DOM element does not have a size yet, resulting in a zero offset of the
         * volume slider knob, no matter what the actual volume setting on the player is. Out of lack of a way to
         * detect when the element gets its size, we use this hack that actually seems to work on all browsers.
         */
        new timeout_1.Timeout(1, function () {
            self.refreshPlaybackPosition();
        }).start();
    };
    return VolumeSlider;
}(seekbar_1.SeekBar));
exports.VolumeSlider = VolumeSlider;
